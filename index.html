<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pok√©mon Bracket Generator</title>
  <style>
    :root{
      --bg:#0b0f1a; --panel:#121a2e; --text:#eaf0ff; --muted:#9fb2ff;
      --accent:#87a7ff; --accent2:#94f7c3; --line:rgba(255,255,255,.12);
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0f1a,#0e1530);color:var(--text);
         font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    h1{margin:0 0 6px;font-size:28px;font-weight:800}
    .sub{color:var(--muted);margin:0 0 18px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015));
          border:1px solid var(--line); border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .grid{display:grid; gap:16px; grid-template-columns: 1.2fr .8fr}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{background:var(--accent); color:#08132a; border:none; font-weight:800; padding:12px 14px;
         border-radius:12px; cursor:pointer; transition:.15s transform ease}
    .btn:hover{ transform: translateY(-1px)}
    .btn.secondary{ background:transparent; color:var(--text); border:1px solid var(--line)}
    .pill{font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid var(--line); color:var(--muted)}
    .sep{height:1px; background:var(--line); margin:12px 0}
    input[type=number], input[type=text]{background:#0b1430; color:var(--text); border:1px solid var(--line);
      border-radius:10px; padding:8px 10px; min-width:70px}
    label{font-size:14px}
    .stat{font-size:13px; color:var(--muted)}
    .choice{border:1px solid var(--line); border-radius:14px; padding:22px; cursor:pointer;
            display:flex; align-items:center; justify-content:center; flex-direction: column; gap: 8px; text-align: center;
            background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01));
            font-size:22px; font-weight:900; letter-spacing:.3px; text-transform:capitalize}
    .sprite{ display:block; }
    .choice:hover{border-color:rgba(255,255,255,.22); transform: translateY(-1px)}
    .match{display:grid; grid-template-columns:1fr 70px 1fr; align-items:stretch; gap:10px}
    .vs{display:flex; align-items:center; justify-content:center; color:var(--muted); font-weight:800}
    .small{font-size:12px; color:var(--muted)}
    table{width:100%; border-collapse:separate; border-spacing:0 8px}
    th,td{padding:8px 10px; font-size:14px}
    th{color:var(--muted); text-align:left}
    tr{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015))}
    tr td:first-child, tr th:first-child{border-top-left-radius:10px; border-bottom-left-radius:10px}
    tr td:last-child, tr th:last-child{border-top-right-radius:10px; border-bottom-right-radius:10px}
    .rank{color:#a8b9ff; font-weight:800}
    .wrap-scroll{max-height:380px; overflow:auto; padding-right:6px}
    .kbd{font-size:11px; color:#06122b; background:#cfe1ff; padding:2px 6px; border-radius:6px; font-weight:800}
    .multiselect{ position:relative; display:inline-block }
    .multiselect .dropdown label{ font-size:13px; color:var(--text) }
    .multiselect .dropdown input{ margin-right:6px }
    .multiselect .dropdown{ max-height:280px; overflow:auto; min-width:260px }
    .multiselect .dropdown .row{ display:grid; grid-template-columns: repeat(3, minmax(110px,1fr)); gap:8px }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Pok√©mon Bracket Generator</h1>
    <p class="sub">Build a full single-elimination bracket for all current Pok√©mon species. The tool fetches the live species list from Pok√©API, has filters and shuffle, and lets you pick winners round-by-round.</p>

    <div class="grid">
      <section class="card">
        <h2 style="margin:0 0 10px">1) Fetch List & Configure</h2>
        <div class="row" style="margin-bottom:8px">
          <button id="fetchBtn" class="btn">Fetch from Pok√©API</button>
          <span id="fetchStat" class="stat">Not fetched yet</span>
        </div>

        <div class="sep"></div>
        <h3 class="small" style="margin:0 0 6px">Filters</h3>
        <div class="row" style="margin-bottom:8px; align-items:flex-end">
          <div>
            <label>Generation</label><br>
            <div class="multiselect">
              <button id="genDropdownBtn" type="button" class="btn secondary" style="padding:8px 10px">All</button>
              <div id="genDropdown" class="dropdown" style="display:none; position:absolute; z-index:10; background:#0b1430; border:1px solid var(--line); border-radius:10px; padding:10px; box-shadow:0 10px 30px rgba(0,0,0,.35)">
                <div class="row" style="gap:14px; flex-wrap:wrap; max-width:320px">
                  <label><input type="checkbox" name="genCheck" value="1"> Gen 1</label>
                  <label><input type="checkbox" name="genCheck" value="2"> Gen 2</label>
                  <label><input type="checkbox" name="genCheck" value="3"> Gen 3</label>
                  <label><input type="checkbox" name="genCheck" value="4"> Gen 4</label>
                  <label><input type="checkbox" name="genCheck" value="5"> Gen 5</label>
                  <label><input type="checkbox" name="genCheck" value="6"> Gen 6</label>
                  <label><input type="checkbox" name="genCheck" value="7"> Gen 7</label>
                  <label><input type="checkbox" name="genCheck" value="8"> Gen 8</label>
                  <label><input type="checkbox" name="genCheck" value="9"> Gen 9</label>
                </div>
              </div>
            </div>
          </div>

          <div>
            <label>Type(s)</label><br>
            <div class="multiselect">
              <button id="typeDropdownBtn" type="button" class="btn secondary" style="padding:8px 10px">Select types</button>
              <div id="typeDropdown" class="dropdown" style="display:none; position:absolute; z-index:10; background:#0b1430; border:1px solid var(--line); border-radius:10px; padding:10px; box-shadow:0 10px 30px rgba(0,0,0,.35)">
                <div class="row" style="gap:14px; flex-wrap:wrap; max-width:320px">
                  <label><input type="checkbox" value="normal"> Normal</label>
                  <label><input type="checkbox" value="fire"> Fire</label>
                  <label><input type="checkbox" value="water"> Water</label>
                  <label><input type="checkbox" value="electric"> Electric</label>
                  <label><input type="checkbox" value="grass"> Grass</label>
                  <label><input type="checkbox" value="ice"> Ice</label>
                  <label><input type="checkbox" value="fighting"> Fighting</label>
                  <label><input type="checkbox" value="poison"> Poison</label>
                  <label><input type="checkbox" value="ground"> Ground</label>
                  <label><input type="checkbox" value="flying"> Flying</label>
                  <label><input type="checkbox" value="psychic"> Psychic</label>
                  <label><input type="checkbox" value="bug"> Bug</label>
                  <label><input type="checkbox" value="rock"> Rock</label>
                  <label><input type="checkbox" value="ghost"> Ghost</label>
                  <label><input type="checkbox" value="dragon"> Dragon</label>
                  <label><input type="checkbox" value="dark"> Dark</label>
                  <label><input type="checkbox" value="steel"> Steel</label>
                  <label><input type="checkbox" value="fairy"> Fairy</label>
                </div>
              </div>
            </div>
          </div>

          <div>
            <label>Exclusions</label><br>
            <div class="multiselect">
              <button id="exDropdownBtn" type="button" class="btn secondary" style="padding:8px 10px">None</button>
              <div id="exDropdown" class="dropdown" style="display:none; position:absolute; z-index:10; background:#0b1430; border:1px solid var(--line); border-radius:10px; padding:10px; box-shadow:0 10px 30px rgba(0,0,0,.35)">
                <div class="row" style="gap:14px; flex-wrap:wrap; max-width:360px">
                  <label><input id="exMegaPrimal" type="checkbox" value="megaPrimal"> Megas & Primal</label>
                  <label><input id="exGmax" type="checkbox" value="gmax"> Gmax</label>
                  <label><input id="exCostume" type="checkbox" value="costume"> Costumes</label>
                  <label><input id="exAltForms" type="checkbox" value="altForms"> Alternate forms (keeps only defaults)</label>
                </div>
              </div>
            </div>
          </div>

          <button id="applyFilterBtn" class="btn">Apply Filters</button>
          <span id="filterStat" class="stat"></span>
        </div>

        <div class="row" style="margin-bottom:8px">
          <button id="shuffleBtn" class="btn">Shuffle List</button>
          <span id="shuffleStat" class="stat"></span>
          </label>
        </div>

        <div class="row">
          <button id="buildBtn" class="btn">Build Bracket</button>
          <span id="buildStat" class="stat"></span>
        </div>

        <div class="sep"></div>

        <h2 style="margin:0 0 10px">2) Play Matches</h2>
        <div class="row small" style="margin-bottom:6px">
          <span>Use keyboard: <span class="kbd">1</span>/<span class="kbd">2</span> to pick, <span class="kbd">U</span> to undo, <span class="kbd">S</span> to skip</span>
        </div>
        <div id="roundInfo" class="stat" style="margin-bottom:8px; display:none"></div>
        <div id="matchArea" class="match">
          <div id="left" class="choice"></div>
          <div class="vs">VS</div>
          <div id="right" class="choice"></div>
        </div>

        <div class="row" style="margin-top:10px">
          <button id="undoBtn" class="btn secondary" disabled>Undo</button>
          <button id="skipBtn" class="btn secondary" disabled>Skip Pair</button>
        </div>
      </section>

      <section class="card">
        <h2 style="margin:0 0 10px">Live Status</h2>
        <div class="sep"></div>
        <h3 class="small" style="margin:0 0 6px">Match Log</h3>
        <div class="wrap-scroll">
            <table>
              <thead>
                <tr><th>Round</th><th>Match</th><th>Contenders</th><th>Winner</th></tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
        </div>
        <div class="sep"></div>
        <div id="finalArea" style="display:none">
          <h3 style="margin:0 0 6px">Champion</h3>
          <div id="champion" class="choice" style="cursor:default"></div>
        </div>
      </section>
    </div>
  </div>

  <script>
      // allPokemon: Array of entries. Each entry.meta (populated after enrich) includes:
      //   speciesId, speciesName, speciesVarieties, isDefaultMon, formIsDefault,
      //   isMega/Gmax/Primal/Costume, isRegional/regionTag, generationNum, types
      let allPokemon = [];
      // Helper to safely get a resource name from NamedAPIResource or URL
      function nameOfResource(x){
        if (!x) return '';
        if (typeof x === 'string') return String(x).split('/').filter(Boolean).pop() || '';
        if (x.name) return x.name;
        if (x.url) return String(x.url).split('/').filter(Boolean).pop() || '';
        return '';
      }

      let bracketPairs = [];
      let pairIndex = 0;
      let bracketHistory = [];
      let currentRound = 0;
      let roundStack = [];
      let isTransitioning = false;
      let workingPool = []; // filtered subset to build from
      const detailCache = new Map();      // name -> /pokemon detail JSON
      const speciesCache = new Map();     // speciesId -> /pokemon-species JSON
      const formCache = new Map();        // variety name -> /pokemon-form JSON
      const versionGroupCache = new Map();// vg name -> /version-group JSON

      // --- Lightweight localStorage cache for meta enrichment ---
      const META_CACHE_KEY = 'pb_meta_cache_v1';
      function loadMetaCache(){
        try { return JSON.parse(localStorage.getItem(META_CACHE_KEY) || '{}'); } catch { return {}; }
      }
      function saveMetaCache(cache){
        try { localStorage.setItem(META_CACHE_KEY, JSON.stringify(cache)); } catch {}
      }
      let metaCache = loadMetaCache(); // keyed by entry.name (variety)
      
      
      const ui = {
        fetchBtn: document.getElementById('fetchBtn'),
        fetchStat: document.getElementById('fetchStat'),
        shuffleBtn: document.getElementById('shuffleBtn'),
        shuffleStat: document.getElementById('shuffleStat'),
        buildBtn: document.getElementById('buildBtn'),
        buildStat: document.getElementById('buildStat'),
        left: document.getElementById('left'),
        right: document.getElementById('right'),
        historyBody: document.getElementById('historyBody'),
        undoBtn: document.getElementById('undoBtn'),
        skipBtn: document.getElementById('skipBtn'),
        typeDropdownBtn: document.getElementById('typeDropdownBtn'),
        typeDropdown: document.getElementById('typeDropdown'),
        applyFilterBtn: document.getElementById('applyFilterBtn'),
        filterStat: document.getElementById('filterStat'),
        genDropdownBtn: document.getElementById('genDropdownBtn'),
        genDropdown: document.getElementById('genDropdown'),
        exDropdownBtn: document.getElementById('exDropdownBtn'),
        exDropdown: document.getElementById('exDropdown'),
        exMegaPrimal: document.getElementById('exMegaPrimal'),
        exGmax: document.getElementById('exGmax'),
        exCostume: document.getElementById('exCostume'),
        exAltForms: document.getElementById('exAltForms')
      };
      // Default exclusions ON (users can uncheck if desired)
      if (ui.exMegaPrimal) ui.exMegaPrimal.checked = true;
      if (ui.exGmax)       ui.exGmax.checked = true;
      if (ui.exCostume)    ui.exCostume.checked = true;
      if (ui.exAltForms)   ui.exAltForms.checked = true;
      // Reflect in the dropdown button label
      if (ui.exDropdownBtn) ui.exDropdownBtn.textContent = 'Alt forms, Megas/Primal, Gmax, Costumes';
      // --- Gen and Exclusion dropdown helpers ---
      function getSelectedGens() {
        return Array.from(document.querySelectorAll('input[name="genCheck"]:checked')).map(el => Number(el.value));
      }
      function getExclusions() {
        return {
          altForms:   ui.exAltForms?.checked   || false,
          megaPrimal: ui.exMegaPrimal?.checked || false,
          gmax:       ui.exGmax?.checked       || false,
          costume:    ui.exCostume?.checked    || false,
        };
      }
      // Helper to detect form flags (mega/gmax/primal/costume) using pokemon-form metadata
      async function getFormFlags(entry) {
        const id = idFromPokemonUrl(entry.url);
        // Fast path if meta exists
        if (entry.meta) {
          return {
            isForm: !!entry.meta.isForm,
            isMega: !!entry.meta.isMega,
            isGmax: !!entry.meta.isGmax,
            isPrimal: !!entry.meta.isPrimal,
            isCostume: !!entry.meta.isCostume,
          };
        }
        // Default flags
        const flags = { isForm: id >= 10000, isMega: false, isGmax: false, isPrimal: false, isCostume: false };
        if (!flags.isForm) return flags;
        // costume heuristic by name (covers Pikachu hats & cosplays)
        const n = (entry.name || '').toLowerCase();
        if (n.startsWith('pikachu-')) {
          const cosplaySet = ['rock-star','belle','pop-star','phd','libre'];
          if (cosplaySet.some(t => n.includes(t)) || n.includes('cap') || n.includes('cosplay')) {
            flags.isCostume = true;
          }
        }
        const form = await getFormMetaByName(entry.name);
        const formName = (form && (form.form_name || form.name)) || entry.name || '';
        flags.isMega = !!(form && form.is_mega);
        flags.isGmax = /gmax|gigantamax/i.test(formName);
        flags.isPrimal = /primal/i.test(formName);
        return flags;
      }

      function isRegionalForm(entry) {
        if (entry.meta && typeof entry.meta.isRegional === 'boolean') return entry.meta.isRegional;
        const n = (entry?.name || '').toLowerCase();
        // treat tokens like -alola, -galar, -hisui, -paldea as regional
        return /(?:^|[-])(alola|galar|hisui|paldea)(?:$|[-])/.test(n);
      }

      // --- Regional form helpers ---
      function extractRegionTag(name) {
        const m = String(name || '').toLowerCase().match(/(?:^|[-])(alola|galar|hisui|paldea)(?:$|[-])/);
        return m ? m[1] : null;
      }

      function regionalBaseName(entry, detail) {
        const base = detail?.species?.name || entry?.name || '';
        const tag = extractRegionTag(entry?.name);
        return tag ? `${base}-${tag}` : base;
      }

      // ---- Meta enrichment ----
      function parseRegionTagByName(name) {
        const m = String(name || '').toLowerCase().match(/(?:^|[-])(alola|galar|hisui|paldea)(?:$|[-])/);
        return m ? m[1] : null;
      }

      function setEntryMeta(entry, meta) {
        entry.meta = Object.assign(entry.meta || {}, meta);
        return entry.meta;
      }

      async function enrichEntry(entry) {
        // Fast path: if meta already attached or cached, use it
        if (entry.meta && entry.meta.speciesId) return entry.meta;
        const cached = metaCache[entry.name];
        if (cached && cached.speciesId) { entry.meta = cached; return cached; }
        try {
          const id = idFromPokemonUrl(entry.url);
          const isForm = id >= 10000;
          const detail = await getPokemonDetail(entry);
          if (!detail) {
            const meta = setEntryMeta(entry, { id, isForm });
            metaCache[entry.name] = meta;
            return meta;
          }

          // --- Expanded meta fields ---
          const speciesUrl = detail?.species?.url || '';
          const speciesId = Number(String(speciesUrl).split('/').filter(Boolean).pop());
          const speciesName = detail?.species?.name || '';
          const isDefaultMon = !!detail?.is_default; // default variety for this specific pokemon

          // forms array from /pokemon (NamedAPIResource list)
          const formsList = Array.isArray(detail.forms) ? detail.forms.map(f => nameOfResource(f)) : [];

          // Types
          const types = (detail.types || []).map(t => t.type.name);

          // Region tag (from variety name)
          const regionTag = parseRegionTagByName(entry.name);
          const isRegional = !!regionTag;

          // Form metadata (for special categories + intro generation if needed)
          let isMega = false, isGmax = false, isPrimal = false, isCostume = false, genNum = null, formIsDefault = null, formVersionGroup = '';
          if (isForm) {
            const form = await getFormMetaByName(entry.name);
            if (form) {
              formIsDefault = typeof form.is_default === 'boolean' ? form.is_default : null;
              formVersionGroup = form?.version_group?.name || '';
              const formName = (form.form_name || form.name || '').toLowerCase();
              isMega = !!form.is_mega;
              isGmax = /gmax|gigantamax/.test(formName);
              isPrimal = /primal/.test(formName);
              // costumes (mostly Pikachu caps/cosplays)
              if ((entry.name || '').toLowerCase().startsWith('pikachu-')) {
                const cosplaySet = ['rock-star','belle','pop-star','phd','libre'];
                if (cosplaySet.some(t => formName.includes(t)) || formName.includes('cap') || formName.includes('cosplay')) {
                  isCostume = true;
                }
              }
            }
          }

          // Generation: prefer form version group for forms
          if (isForm && formVersionGroup) {
            const vg = await getVersionGroup(formVersionGroup);
            genNum = genNameToNum(vg?.generation?.name || '') || genNum;
          }
          if (!genNum) {
            const sp = speciesUrl ? await getSpecies(speciesUrl) : null;
            const gname = sp?.generation?.name || '';
            genNum = genNameToNum(gname) || null;
          }

          // Species varieties (from /pokemon-species): allows cheap alt-form collapse by species
          let speciesVarieties = [];
          {
            const sp = speciesUrl ? await getSpecies(speciesUrl) : null;
            if (sp && Array.isArray(sp.varieties)) {
              speciesVarieties = sp.varieties.map(v => ({
                name: v?.pokemon?.name || '',
                is_default: !!v?.is_default,
              }));
            }
          }

          const meta = setEntryMeta(entry, {
            id, isForm,
            speciesId, speciesName, speciesUrl,
            isDefaultMon,
            formsList,
            formIsDefault,
            formVersionGroup,
            regionTag, isRegional,
            isMega, isGmax, isPrimal, isCostume,
            generationNum: genNum,
            types,
            speciesVarieties,
          });
          metaCache[entry.name] = meta;
          return meta;
        } catch {
          const meta = setEntryMeta(entry, { id: idFromPokemonUrl(entry.url) });
          metaCache[entry.name] = meta;
          return meta;
        }
      }

      async function enrichEntries(entries, concurrency = 36) {
        let next = 0, done = 0;
        async function worker() {
          while (true) {
            const i = next++;
            if (i >= entries.length) return;
            await enrichEntry(entries[i]);
            done++;
            if (done % 25 === 0 || done === entries.length) {
              ui.fetchStat.textContent = `${ui.fetchStat.textContent.replace(/\s*\|.*$/, '')} | Enriched ${done}/${entries.length}`;
            }
            await new Promise(r => setTimeout(r, 0));
          }
        }
        await Promise.all(Array.from({ length: concurrency }, worker));
        saveMetaCache(metaCache);
      }

      // Produce a nicer display name when Alt Forms exclusion is active.
      // Only affects entries that are forms (id >= 10000) and are NOT regional/mega/gmax/primal/costume.
      function prettyName(entry, ex) {
        // Only honor overrides when Alt Forms collapse is active
        if (ex && ex.altForms && entry && entry._displayNameOverride) return entry._displayNameOverride;
        return (entry?.name || '').trim() || '(unknown)';
      }

      function displayName(entry) {
        if (!entry) return '(unknown)';
        if (typeof entry === 'string') return entry;
        // read current exclusions live from UI
        const ex = typeof getExclusions === 'function' ? getExclusions() : { altForms: false };
        return prettyName(entry, ex);
      }
      
      function idFromPokemonUrl(durl) {
          return Number(String(durl).split('/').filter(Boolean).pop());
      }
      
      function artworkUrlFromId(id) {
          return `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`;
      }

      // --- Filtering helpers ---
      async function getPokemonDetail(entry) {
        const key = (entry && entry.name) || '';
        if (detailCache.has(key)) return detailCache.get(key);
        const data = await fetch(entry.url).then(r => r.ok ? r.json() : null);
        detailCache.set(key, data);
        return data;
      }

      async function getSpecies(speciesUrl) {
        const id = Number(String(speciesUrl).split('/').filter(Boolean).pop());
        if (speciesCache.has(id)) return speciesCache.get(id);
        const data = await fetch(speciesUrl).then(r => r.ok ? r.json() : null);
        speciesCache.set(id, data);
        return data;
      }

      async function getFormMetaByName(varietyName) {
        if (formCache.has(varietyName)) return formCache.get(varietyName);
        const data = await fetch(`https://pokeapi.co/api/v2/pokemon-form/${varietyName}`).then(r => r.ok ? r.json() : null);
        formCache.set(varietyName, data);
        return data;
      }

      async function getVersionGroup(name) {
        if (versionGroupCache.has(name)) return versionGroupCache.get(name);
        const data = await fetch(`https://pokeapi.co/api/v2/version-group/${name}`).then(r => r.ok ? r.json() : null);
        versionGroupCache.set(name, data);
        return data;
      }

      // Resolve generation for an entry:
      //  - For regular species (id < 10000): use species.generation.name
      //  - For alt forms (id >= 10000): use pokemon-form.version_group.generation
      async function resolveGeneration(entry) {
        if (entry.meta && entry.meta.generationNum) {
          const mapBack = {1:'generation-i',2:'generation-ii',3:'generation-iii',4:'generation-iv',5:'generation-v',6:'generation-vi',7:'generation-vii',8:'generation-viii',9:'generation-ix'};
          return mapBack[entry.meta.generationNum] || '';
        }
        const id = idFromPokemonUrl(entry.url);
        // first get /pokemon detail to locate species url
        const detail = await getPokemonDetail(entry);
        if (!detail) return '';
        const speciesUrl = detail?.species?.url;
        if (!speciesUrl) return '';
        if (id < 10000) {
          const sp = await getSpecies(speciesUrl);
          return sp?.generation?.name || '';
        }
        // form case
        const form = await getFormMetaByName(entry.name);
        if (!form) {
          const sp = await getSpecies(speciesUrl);
          return sp?.generation?.name || '';
        }
        const vg = await getVersionGroup(form?.version_group?.name);
        return vg?.generation?.name || '';
      }

      async function resolveTypes(entry) {
        if (entry.meta && Array.isArray(entry.meta.types)) return entry.meta.types.slice();
        const detail = await getPokemonDetail(entry);
        if (!detail) return [];
        return (detail.types || []).map(t => t.type.name);
      }

      function probeImage(url, timeoutMs = 7000) {
        return new Promise(resolve => {
          const img = new Image();
          const timer = setTimeout(() => {
            cleanup(); resolve(false);
          }, timeoutMs);

          function cleanup() {
            clearTimeout(timer);
            img.onload = null;
            img.onerror = null;
          }

          img.onload = () => { cleanup(); resolve(true); };
          img.onerror = () => { cleanup(); resolve(false); };
          img.src = url;
        });
      }
      // Helper to get selected types from the dropdown
      function getSelectedTypes() {
        const box = ui.typeDropdown;
        if (!box) return [];
        return Array.from(box.querySelectorAll('input[type="checkbox"]:checked')).map(x => x.value);
      }

      // Fast generation ranges for filtering
      const genRanges = { 1:[1,151], 2:[152,251], 3:[252,386], 4:[387,493], 5:[494,649], 6:[650,721], 7:[722,809], 8:[810,905], 9:[906,1025] };

      function genNameToNum(gname) {
        const map = {
          'generation-i': 1,
          'generation-ii': 2,
          'generation-iii': 3,
          'generation-iv': 4,
          'generation-v': 5,
          'generation-vi': 6,
          'generation-vii': 7,
          'generation-viii': 8,
          'generation-ix': 9,
        };
        return map[gname] || null;
      }

      async function applyFilters() {
        if (!allPokemon.length) { ui.filterStat.textContent = 'Fetch first'; return; }
        const genSel = getSelectedGens();
        const selectedTypes = getSelectedTypes();
        const ex = getExclusions();

        const needGen = genSel.length > 0;
        const needTypes = selectedTypes.length > 0;
        if (genSel.length === 0 && selectedTypes.length === 0 && !ex.altForms && !ex.megaPrimal && !ex.gmax && !ex.costume) {
          workingPool = allPokemon.slice();
          ui.filterStat.textContent = `Filtered: ${workingPool.length} / ${allPokemon.length}`;
          return;
        }

        ui.filterStat.textContent = 'Filtering‚Ä¶';
        try {
          let next = 0, done = 0;
          const concurrency = 24;

          async function testEntry(e) {
            const id = idFromPokemonUrl(e.url);
            const meta = e.meta || null;
            let flags = null; // cache for form flags so we don't fetch twice
            // ALT FORMS handling ‚Äî data‚Äëdriven collapse to API defaults
            // Rule: keep ONLY a single default variety per species (or per regional), drop alternates.
            // We use: pokemon-form.is_default (for forms), pokemon.is_default (for species),
            // and as a final fallback, species.varieties[is_default].
            if (ex.altForms) {
              const m = e.meta || {};
              const isSpecial = !!(m.isMega || m.isGmax || m.isPrimal || m.isCostume);
              if (!isSpecial) {
                if (m.isForm === true) {
                  // FORM ENTRIES (id >= 10000 or flagged in meta)
                  if (m.formIsDefault === false) return false; // non‚Äëdefault form ‚Äî drop
                  if (m.formIsDefault === true) {
                    // default form ‚Äî keep, label nicely
                    e._displayNameOverride = m.isRegional
                      ? regionalBaseName(e, { species: { name: m.speciesName } })
                      : (m.speciesName || e.name);
                  } else {
                    // Unknown form default; prefer pokemon default, else species.varieties default
                    if (m.isDefaultMon === false) return false;
                    if (m.isDefaultMon === true) {
                      e._displayNameOverride = m.speciesName || e.name;
                    } else if (!m.isRegional && Array.isArray(m.speciesVarieties) && m.speciesVarieties.length) {
                      const def = m.speciesVarieties.find(v => v.is_default);
                      if (def && def.name && def.name !== e.name) return false; // keep only the default variety name
                      e._displayNameOverride = m.speciesName || e.name;
                    } else {
                      // Regional with unknown flags: be permissive and keep (default sub‚Äëform is typically flagged on forms)
                      e._displayNameOverride = m.isRegional
                        ? regionalBaseName(e, { species: { name: m.speciesName } })
                        : (m.speciesName || e.name);
                    }
                  }
                } else {
                  // NON‚ÄëFORM ENTRIES (id < 10000)
                  if (m.isDefaultMon === false) return false; // not species default ‚Äî drop
                  if (m.isDefaultMon === true) {
                    e._displayNameOverride = m.isRegional
                      ? regionalBaseName(e, { species: { name: m.speciesName } })
                      : (m.speciesName || e.name);
                  } else if (Array.isArray(m.speciesVarieties) && m.speciesVarieties.length) {
                    // Fallback to species default variety name
                    const def = m.speciesVarieties.find(v => v.is_default);
                    if (def && def.name && def.name !== e.name) return false; // keep only default variety (fixes Minior cores)
                    e._displayNameOverride = m.isRegional
                      ? regionalBaseName(e, { species: { name: m.speciesName } })
                      : (m.speciesName || e.name);
                  } else {
                    // No info ‚Äî keep as last resort (rare)
                    e._displayNameOverride = m.speciesName || e.name;
                  }
                }
              }
            }
            // 2.2 Independent exclusions (apply regardless of altForms)
            if ((meta && meta.isForm) || id >= 10000) {
              if (meta) {
                if (ex.megaPrimal && (meta.isMega || meta.isPrimal)) return false;
                if (ex.gmax && meta.isGmax) return false;
                if (ex.costume && meta.isCostume) return false;
              } else {
                if (!flags) { flags = await getFormFlags(e); }
                const { isMega, isGmax, isPrimal, isCostume } = flags;
                if (ex.megaPrimal && (isMega || isPrimal)) return false;
                if (ex.gmax && isGmax) return false;
                if (ex.costume && isCostume) return false;
              }
            }

            // --- Generation check ---
            if (needGen) {
              if (meta) {
                if (!meta.isForm) {
                  // Regular species: fast range check by National Dex id
                  const anyInRange = genSel.some(g => {
                    const [lo, hi] = genRanges[g];
                    return id >= lo && id <= hi;
                  });
                  if (!anyInRange) return false;
                } else {
                  // Form entry
                  if (meta.isMega || meta.isGmax || meta.isPrimal || meta.isCostume) {
                    // Special forms inherit base species generation via speciesId range
                    const spId = meta.speciesId || id; // fallback to id just in case
                    const ok = genSel.some(g => {
                      const [lo, hi] = genRanges[g];
                      return spId >= lo && spId <= hi;
                    });
                    if (!ok) return false;
                  } else {
                    // Regional/other forms: rely on resolved generation number
                    const gnum = meta.generationNum || null;
                    if (gnum) {
                      if (!genSel.includes(gnum)) return false;
                    } else {
                      // Fallback to old path if meta missing
                      const form = await getFormMetaByName(e.name);
                      const vgName = form?.version_group?.name || '';
                      if (!vgName) {
                        const detail = await getPokemonDetail(e);
                        const spId = Number(String(detail?.species?.url || '').split('/').filter(Boolean).pop());
                        const ok = genSel.some(g => {
                          const [lo, hi] = genRanges[g];
                          return spId >= lo && spId <= hi;
                        });
                        if (!ok) return false;
                      } else {
                        const vg = await getVersionGroup(vgName);
                        const gnum2 = genNameToNum(vg?.generation?.name || '');
                        if (!genSel.includes(gnum2)) return false;
                      }
                    }
                  }
                }
              } else {
                // No meta: fallback to previous logic
                if (id < 10000) {
                  const anyInRange = genSel.some(g => {
                    const [lo, hi] = genRanges[g];
                    return id >= lo && id <= hi;
                  });
                  if (!anyInRange) return false;
                } else {
                  if (!flags) { flags = await getFormFlags(e); }
                  const { isMega, isGmax, isPrimal, isCostume } = flags;
                  if (isMega || isGmax || isPrimal || isCostume) {
                    const detail = await getPokemonDetail(e);
                    const spId = Number(String(detail?.species?.url || '').split('/').filter(Boolean).pop());
                    const ok = genSel.some(g => {
                      const [lo, hi] = genRanges[g];
                      return spId >= lo && spId <= hi;
                    });
                    if (!ok) return false;
                  } else {
                    const form = await getFormMetaByName(e.name);
                    const vgName = form?.version_group?.name || '';
                    if (!vgName) {
                      const detail = await getPokemonDetail(e);
                      const spId = Number(String(detail?.species?.url || '').split('/').filter(Boolean).pop());
                      const ok = genSel.some(g => {
                        const [lo, hi] = genRanges[g];
                        return spId >= lo && spId <= hi;
                      });
                      if (!ok) return false;
                    } else {
                      const vg = await getVersionGroup(vgName);
                      const gnum = genNameToNum(vg?.generation?.name || '');
                      if (!genSel.includes(gnum)) return false;
                    }
                  }
                }
              }
            }

            // --- Types check ---
            if (needTypes) {
              const types = await resolveTypes(e);
              for (const t of selectedTypes) { if (!types.includes(t)) return false; }
            }
            return true;
          }

          const results = new Array(allPokemon.length);
          async function worker() {
            while (true) {
              const i = next++;
              if (i >= allPokemon.length) return;
              results[i] = await testEntry(allPokemon[i]);
              done++;
              if (done % 25 === 0 || done === allPokemon.length) ui.filterStat.textContent = `Filtering‚Ä¶ ${done}/${allPokemon.length}`;
              await new Promise(r => setTimeout(r, 0));
            }
          }
          await Promise.all(Array.from({length: concurrency}, worker));

          const out = [];
          for (let i = 0; i < results.length; i++) if (results[i]) out.push(allPokemon[i]);
          // When Alt Forms is ON, dedupe by species (+region) and prefer API default entries
          if (ex.altForms) {
            const buckets = new Map();
            for (const e of out) {
              const m = e.meta || {};
              const speciesKey = m.speciesId || m.speciesName || e.name;
              const key = m.isRegional ? `${speciesKey}:${m.regionTag || 'base'}` : String(speciesKey);
              if (!buckets.has(key)) buckets.set(key, []);
              buckets.get(key).push(e);
            }
            const deduped = [];
            for (const [, arr] of buckets) {
              const isSpecial = (m) => !!(m?.isMega || m?.isGmax || m?.isPrimal || m?.isCostume);

              // 1) Prefer non‚Äëspecial entries that are explicit defaults
              let pick = arr.find(x => !isSpecial(x.meta) && (x?.meta?.formIsDefault === true || x?.meta?.isDefaultMon === true));

              // 2) Otherwise prefer any non‚Äëspecial entry (even if flags missing)
              if (!pick) pick = arr.find(x => !isSpecial(x.meta));

              // 3) Otherwise prefer any default (even if special) as a last resort
              if (!pick) pick = arr.find(x => x?.meta?.formIsDefault === true || x?.meta?.isDefaultMon === true);

              // 4) Fallback to first
              if (!pick) pick = arr[0];

              deduped.push(pick);
            }
            workingPool = deduped;
          } else {
            workingPool = out;
          }

          // If Alt Forms is OFF, ensure names show exact forms (no leftover overrides)
          if (!ex.altForms && workingPool.length) {
            for (const e of workingPool) { if (e && e._displayNameOverride) delete e._displayNameOverride; }
          }

          // If Alt Forms is active, ensure surviving default forms display as base species or species-region for regionals
          if (ex.altForms && workingPool.length) {
            ui.filterStat.textContent = `Filtered: ${workingPool.length} / ${allPokemon.length} ‚Äî normalizing names‚Ä¶ 0/${workingPool.length}`;
            let doneNorm = 0;
            for (let i = 0; i < workingPool.length; i++) {
                const e = workingPool[i];
                const m = e.meta || {};
                if (!(m.isMega || m.isGmax || m.isPrimal || m.isCostume)) {
                  const clean = m.isRegional
                    ? regionalBaseName(e, { species: { name: m.speciesName } })
                    : (m.speciesName || e.name);
                  if (clean) e._displayNameOverride = clean;
                }
              doneNorm++;
              if ((doneNorm & 31) === 0 || doneNorm === workingPool.length) {
                ui.filterStat.textContent = `Filtered: ${workingPool.length} / ${allPokemon.length} ‚Äî normalizing names‚Ä¶ ${doneNorm}/${workingPool.length}`;
                await new Promise(r => setTimeout(r, 0));
              }
            }
          }

          ui.filterStat.textContent = `Filtered: ${workingPool.length} / ${allPokemon.length}`;
        } catch (err) {
          console.error('Filter failed:', err);
          ui.filterStat.textContent = 'Filter failed ‚Äî using full list';
          workingPool = allPokemon.slice();
        }
      }

      // --- Artwork helpers ---
      function preloadOfficialArtwork(entry) {
        const id = idFromPokemonUrl(entry.url);
        const url = artworkUrlFromId(id);
        return probeImage(url).then(ok => ok ? url : null);
      }

      async function setSpriteInto(containerEl, entry, size = 128) {
        if (!containerEl || !entry) return;
        const name = entry.name || '(unknown)';
        // Try official artwork off-DOM first to avoid 404s on the page
        const official = await preloadOfficialArtwork(entry);
        let src = official;
        if (!src) {
          try {
            const detail = await getPokemonDetail(entry);
            src = detail?.sprites?.other?.home?.front_default || detail?.sprites?.front_default || '';
          } catch { /* ignore */ }
        }
        if (src) {
          const img = document.createElement('img');
          img.className = 'sprite';
          img.alt = name;
          img.width = size; img.height = size;
          img.style.cssText = 'object-fit:contain;filter:drop-shadow(0 8px 20px rgba(0,0,0,.35))';
          img.src = src;
          containerEl.innerHTML = '';
          containerEl.appendChild(img);
        } else {
          containerEl.innerHTML = '<div style="width:128px;height:128px;opacity:.6;display:flex;align-items:center;justify-content:center">üß©</div>';
        }
      }

      // Fast pre-filter: drop Totem/Starter variants by name before artwork probing
      function excludeTotemAndStarter(entries) {
        const re = /-(totem|starter)\b/i;
        return entries.filter(e => !re.test(e.name || ''));
      }

      // Drop forms that are known to lack official artwork/sprites in the public sprite repo
      function excludeKnownBadSprites(entries) {
        // Known problematic variants:
        // - Mimikyu busted form(s)
        // - Koraidon/Miraidon ride/build/mode forms (limited/sprinting/swimming/gliding, low-power/drive/aquatic/glide, etc.)
        const patterns = [
          /^(mimikyu|mimikkyu)-busted(?:-totem)?$/i,
          /^(koraidon|miraidon)-.*(?:build|mode)$/i,
        ];
        return entries.filter(e => !patterns.some(re => re.test(e.name || '')));
      }

      async function fetchPokemon(){
       ui.fetchStat.textContent = 'Fetching‚Ä¶';
       ui.fetchBtn.disabled = true;
       let url = "https://pokeapi.co/api/v2/pokemon";
       const entries = [];
       
       while (url) {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
          const data = await res.json();
          
          for (const p of data.results) {
            entries.push({name: p.name, url: p.url});
          }
          url = data.next;
       }
       ui.fetchStat.textContent = 'Fetched ' + entries.length;

       // Remove Totem and Starter variants before artwork filtering
       const noBosses = excludeTotemAndStarter(entries);
       if (noBosses.length !== entries.length) {
           ui.fetchStat.textContent = `Fetched ${entries.length} ‚Äî removed ${entries.length - noBosses.length} totem/starter variants`;
       }
       // Also remove forms with known-missing artwork (keeps fetch fast without probing every image)
       const noBroken = excludeKnownBadSprites(noBosses);
       if (noBroken.length !== noBosses.length) {
         const removedBroken = noBosses.length - noBroken.length;
         ui.fetchStat.textContent = `Fetched ${entries.length} (removed ${entries.length - noBosses.length} totem/starter; ${removedBroken} no-artwork variants). Enriching‚Ä¶`;
       } else {
           ui.fetchStat.textContent = `Fetched ${entries.length} ‚Äî removed ${entries.length - noBosses.length} totem/starter. Enriching‚Ä¶`;
       }
       allPokemon = noBroken;
       await enrichEntries(allPokemon, 36);
       // Reset any prior filtered pool; user should Apply Filters fresh
       workingPool = []; ui.filterStat.textContent = '';
       ui.fetchStat.textContent = `Ready: ${allPokemon.length} entries`;
       ui.fetchBtn.disabled = false;
      }
      
      function shuffleList() {
        const arr = (workingPool.length ? workingPool : allPokemon);
        if (!arr || arr.length === 0) {
          ui.shuffleStat.textContent = 'Fetch Pok√©mon first!';
          return;
        }
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        // if we shuffled allPokemon and have no workingPool yet, leave as-is
        // if we had a workingPool, keep it as the shuffled source
        ui.shuffleStat.textContent = `Shuffle Complete (${arr.length})`;
      }
      
      function generateBracket(list) {
          const pairs = [];
          for (let i=0; i<list.length; i+=2) {
              const a = list[i];
              const b = list[i+1] || null;
              pairs.push([a,b]);
          }
          return pairs;
      }
      
      function buildBracket(list) {
          if (!list || list.length === 0) {
              ui.buildStat.textContent = "Fetch Pokemon first!"
              return;
          }
          // Clear any previous champion display when starting a new bracket
          const finalArea = document.getElementById('finalArea');
          const champBox  = document.getElementById('champion');
          if (finalArea) finalArea.style.display = 'none';
          if (champBox)  champBox.innerHTML = '';
          const pairs = generateBracket(list);
          bracketPairs = pairs;
          bracketHistory = [];
          updateHistoryLog();
          currentRound = 1;
          pairIndex = 0;
          roundStack = [{ round: 1, pairs: bracketPairs.slice() }];
          ui.undoBtn.disabled = false;
          ui.skipBtn.disabled = false;
          ui.buildStat.textContent = `Bracket built with ${pairs.length} matches in Round 1.`;
          renderCurrentMatch();
          return pairs;
      }
      
      function renderCurrentMatch() {
          const roundInfo = document.getElementById('roundInfo');
          if (!Array.isArray(bracketPairs) || bracketPairs.length === 0) {
            roundInfo.style.display = '';
            roundInfo.textContent = 'No pairs to show. Build the bracket first.';
            ui.left.innerHTML = '';
            ui.right.innerHTML = '';
            ui.undoBtn.disabled = true;
            ui.skipBtn.disabled = true;
            return;
          }
          if (pairIndex >= bracketPairs.length) {
              roundInfo.style.display = '';
              roundInfo.textContent = `Round ${currentRound} complete ‚Äî recorded ${bracketHistory.filter(m => m.round === currentRound).length} matches.`;
              ui.left.innerHTML = '';
              ui.right.innerHTML = '';
              ui.undoBtn.disabled = true;
              ui.skipBtn.disabled = true;
              setTimeout(advanceToNextRound,300);
              return;
          }
          const [a, b] = bracketPairs[pairIndex] || [null, null];
          const leftName  = displayName(a);
          const rightName = b ? displayName(b) : null;

          // Enable/disable buttons for active round
          ui.undoBtn.disabled = false;
          ui.skipBtn.disabled = !b; // disable skip on bye
          
          roundInfo.style.display = '';
          roundInfo.textContent =
            `Round ${currentRound} ‚Äî Match ${pairIndex + 1} of ${bracketPairs.length}`;
            // Ensure both sides are interactive for normal matches
            ui.right.style.pointerEvents = 'auto';
            ui.right.style.opacity = '';
            ui.left.style.pointerEvents = 'auto';
          // Render left/right with hourglass and containers; load sprites async
          ui.left.innerHTML = `
            <div id="leftImg" style="width:128px;height:128px;display:flex;align-items:center;justify-content:center;opacity:.8">‚è≥</div>
            <div class="name">${leftName}</div>
          `;
          ui.right.innerHTML = rightName ? `
            <div id="rightImg" style="width:128px;height:128px;display:flex;align-items:center;justify-content:center;opacity:.8">‚è≥</div>
            <div class="name">${rightName}</div>
          ` : ``;

          // Kick off sprite loads (only if not a bye)
          if (rightName) {
            setSpriteInto(document.getElementById('leftImg'), a, 128);
            setSpriteInto(document.getElementById('rightImg'), b, 128);
          }

          // auto-advance if bye
          // Bye: show only the left contender; user must click left to advance
          if (!rightName) {
            roundInfo.textContent =
              `Round ${currentRound} ‚Äî Match ${pairIndex + 1} of ${bracketPairs.length} (bye ‚Äî click to advance)`;

            // Render left side and load sprite; keep right side empty and non-interactive
            ui.left.innerHTML = `
              <div id="leftImg" style="width:128px;height:128px;display:flex;align-items:center;justify-content:center;opacity:.8">‚è≥</div>
              <div class="name">${leftName}</div>
            `;
            ui.right.innerHTML = '';

            setSpriteInto(document.getElementById('leftImg'), a, 128);

            // Enable undo; skipping a bye doesn't make sense; ensure clicks only on left
            ui.undoBtn.disabled = false;
            ui.skipBtn.disabled = true;
            isTransitioning = false;

            // Make right panel ignore clicks; left is active
            ui.right.style.pointerEvents = 'none';
            ui.right.style.opacity = '0';   // optional; remove this line if you prefer visible empty slot
            ui.left.style.pointerEvents = 'auto';
            return;
          }
      }
      // Undo the last decision (in current round or step back a round)
      function undoLast() {
          // 1) If there is at least one recorded match in the current round, remove it and step back
        for (let i = bracketHistory.length - 1; i >= 0; i--) {
            if (bracketHistory[i].round === currentRound) {
              bracketHistory.splice(i, 1);
              if (pairIndex > 0) pairIndex--; // move back to the prior pair
              updateHistoryLog();
              renderCurrentMatch();
              return;
            }
        }
        // 2) No entries in this round yet -> we likely just advanced. Step back a round if possible.
        if (roundStack.length > 1) {
          // Pop the empty/new round off the stack
          roundStack.pop();
          const top = roundStack[roundStack.length - 1];
          currentRound = top.round;
          bracketPairs = top.pairs.slice();
          // Remove the last recorded match from that previous round (if any)
          let lastIdx = -1;
          for (let i = bracketHistory.length - 1; i >= 0; i--) {
              if (bracketHistory[i].round === currentRound) { lastIdx = i; break; }
          }
          if (lastIdx !== -1) bracketHistory.splice(lastIdx, 1);

          // Set pairIndex to the number of matches still recorded in this round (next to play)
          let doneInRound = 0;
          for (const m of bracketHistory) if (m.round === currentRound) doneInRound++;
          pairIndex = Math.max(0, doneInRound);

          updateHistoryLog();
          renderCurrentMatch();
        }
      }

      // Skip the current pair (move it to end of this round, unless it's a bye)
      function skipCurrentPair() {
        if (pairIndex >= bracketPairs.length) return;
        const pair = bracketPairs[pairIndex];
        const [a, b] = pair || [null, null];
        // If it's a bye, just let the normal flow auto-advance
        if (!b) { return; }
        // Move current pair to the end of the queue for this round
        bracketPairs.splice(pairIndex, 1);
        bracketPairs.push(pair);
        // Update the top of the stack so Undo restores the correct order:
        if (roundStack.length) { roundStack[roundStack.length - 1].pairs = bracketPairs.slice(); }
        // Do not change pairIndex; now a new pair occupies this index
        renderCurrentMatch();
      }
      
      function recordMatch(roundNum, a, b, winner) {
          const matchIndex = bracketHistory.filter(m => m.round === roundNum).length + 1;
          bracketHistory.push({
              round: roundNum,
              match: matchIndex,
              contenders: b ? [displayName(a), displayName(b)] : [displayName(a)],
              winner: displayName(winner),
              winnerObj: winner
          });
          updateHistoryLog();
      }
      
      function pickWinner(side) {
        if (isTransitioning) return;
        if (pairIndex >= bracketPairs.length) return;

        const [a, b] = bracketPairs[pairIndex];
        const isBye = !b;

        if (isBye) {
          // Only left clicks advance a bye
          if (side !== 'left') return;
          recordMatch(currentRound, a, null, a);
          pairIndex++;
          renderCurrentMatch();
          return;
        }

        const winner = side === 'left' ? a : b;
        recordMatch(currentRound, a, b, winner);
        pairIndex++;
        renderCurrentMatch();
      }
      
      function winnersForRound(roundNum) {
          return bracketHistory.filter(m => m.round === roundNum).map(m => m.winnerObj ?? { name: m.winner });
      }
      
      function showChampion(winner) {
        const roundInfo = document.getElementById('roundInfo');
        const finalArea = document.getElementById('finalArea');
        const champBox  = document.getElementById('champion');

        const obj  = (winner && typeof winner === 'object') ? winner : { name: winner };
        const name = displayName(obj) || '(none)';

        // Build sprite URL if we have a detail URL; otherwise show a trophy placeholder
        let imgHtml = `<div style="width:200px;height:200px;display:flex;align-items:center;justify-content:center;opacity:.6">üèÜ</div>`;
        if (obj && obj.url) {
          const id  = idFromPokemonUrl(obj.url);
          const src = artworkUrlFromId(id);
          imgHtml = `<img class="sprite"
                          src="${src}"
                          alt="${name}"
                          data-detail="${obj.url}"
                          onerror="fallbackSprite(this)"
                          style="width:220px;height:220px;object-fit:contain;filter:drop-shadow(0 12px 24px rgba(0,0,0,.45))">`;
        }

        // Update round info and show the champion card
        roundInfo.style.display = '';
        roundInfo.textContent = `Champion: ${name}`;

        finalArea.style.display = '';
        champBox.innerHTML = `
          ${imgHtml}
          <div class="name" style="font-size:24px;font-weight:900;margin-top:6px;text-transform:capitalize">${name}</div>
        `;

        // Disable action buttons at end
        ui.undoBtn.disabled = true;
        ui.skipBtn.disabled = true;
        
        // Clear the active match slots
        ui.left.innerHTML = '';
        ui.right.innerHTML = '';
      }
      
      function advanceToNextRound() {
          const winners = winnersForRound(currentRound);
          if (winners.length <= 1) {
            ui.buildStat.textContent = 'Tournament complete!';
            showChampion(winners[0] || '(none)');
            // Disable action buttons at end
            ui.undoBtn.disabled = true;
            ui.skipBtn.disabled = true;
            return;
          }
          currentRound += 1;
          bracketPairs = generateBracket(winners);
          pairIndex = 0;
          roundStack.push({ round: currentRound, pairs: bracketPairs.slice() });
          ui.buildStat.textContent =     `Round ${currentRound - 1} complete. Starting Round ${currentRound} with ${bracketPairs.length} matches.`;
          renderCurrentMatch();
      }
      
      function updateHistoryLog() {
          const tbody = ui.historyBody;
          if (!tbody) return;
          tbody.innerHTML = '';
          
          for (const m of bracketHistory) {
              const vs = m.contenders.length === 2? `${m.contenders[0]} vs ${m.contenders[1]}` : `${m.contenders[0]} (bye)`;
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>R${m.round}</td>
                              <td>${m.match}</td>
                              <td>${vs}</td>
                              <td class="rank">${m.winner}</td>`;
              tbody.appendChild(tr);
          }
          
          const scroller = tbody.closest('.wrap-scroll');
          if (scroller) scroller.scrollTop = scroller.scrollHeight;
      }
      
      async function fallbackSprite(imgEl) {
        const detailUrl = imgEl?.dataset?.detail;
        if (!detailUrl) { imgEl.style.opacity = 0.4; return; }

        try {
          const res = await fetch(detailUrl);
          if (!res.ok) throw new Error('sprite detail fetch failed');
          const data = await res.json();

          const alt =
            data?.sprites?.other?.home?.front_default ||
            data?.sprites?.front_default || "";

          if (alt) {
            imgEl.onerror = null;         // prevent loops
            imgEl.src = alt;              // swap to working sprite
          } else {
            imgEl.replaceWith(placeholderNode());
          }
        } catch {
          imgEl.replaceWith(placeholderNode());
        }

        function placeholderNode() {
          const div = document.createElement('div');
          div.style.cssText = "width:128px;height:128px;opacity:.6;display:flex;align-items:center;justify-content:center";
          div.textContent = "üß©";
          return div;
        }
      }
      
      ui.fetchBtn.addEventListener('click', fetchPokemon);
      ui.shuffleBtn.addEventListener('click', () => shuffleList());
      ui.applyFilterBtn.addEventListener('click', () => { applyFilters(); });
      ui.buildBtn.addEventListener('click', () => buildBracket(workingPool.length ? workingPool : allPokemon));
      ui.left.addEventListener('click', () => pickWinner('left'));
      ui.right.addEventListener('click', () => pickWinner('right'));
      ui.undoBtn.addEventListener('click', undoLast);
      ui.skipBtn.addEventListener('click', skipCurrentPair);

      // --- Type dropdown open/close logic ---
      ui.typeDropdownBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        ui.typeDropdown.style.display = (ui.typeDropdown.style.display === 'none' || !ui.typeDropdown.style.display) ? 'block' : 'none';
      });
      document.addEventListener('click', (e) => {
        if (!ui.typeDropdown.contains(e.target) && e.target !== ui.typeDropdownBtn) {
          ui.typeDropdown.style.display = 'none';
        }
      });
      // Update button label with current selections
      ui.typeDropdown.addEventListener('change', () => {
        const sel = getSelectedTypes();
        ui.typeDropdownBtn.textContent = sel.length ? `Types (${sel.length})` : 'Select types';
      });
  // --- Gen dropdown ---
  ui.genDropdownBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    ui.genDropdown.style.display = (ui.genDropdown.style.display === 'none' || !ui.genDropdown.style.display) ? 'block' : 'none';
  });
  document.addEventListener('click', (e) => {
    if (!ui.genDropdown.contains(e.target) && e.target !== ui.genDropdownBtn) {
      ui.genDropdown.style.display = 'none';
    }
  });
  ui.genDropdown.addEventListener('change', () => {
    const gens = getSelectedGens();
    ui.genDropdownBtn.textContent = gens.length ? `Gen ${gens.join(',')}` : 'All';
  });

  // --- Exclusions dropdown ---
  ui.exDropdownBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    ui.exDropdown.style.display = (ui.exDropdown.style.display === 'none' || !ui.exDropdown.style.display) ? 'block' : 'none';
  });
  document.addEventListener('click', (e) => {
    if (!ui.exDropdown.contains(e.target) && e.target !== ui.exDropdownBtn) {
      ui.exDropdown.style.display = 'none';
    }
  });

  // --- Keyboard shortcuts for match controls ---
  document.addEventListener('keydown', function(event) {
    // Only respond if no modal/dropdown is open and focus is not in an input
    const active = document.activeElement;
    if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;
    // Keyboard controls:
    // 1: pick left, 2: pick right, U/u: undo, S/s: skip
    if (event.key === '1') {
      pickWinner('left');
    } else if (event.key === '2') {
      pickWinner('right');
    } else if (event.key === 'u' || event.key === 'U') {
      undoLast();
    } else if (event.key === 's' || event.key === 'S') {
      skipCurrentPair();
    }
  });
</script>
</body>
</html>
