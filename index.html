<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
            <meta http-equiv="Content-Style-Type" content="text/css">
            <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
                <title>Pokémon Bracket</title>
                <meta name="title" content="Pokémon Bracket">
                    <meta property="og:title" content="Pokémon Bracket" />
                    <meta name="Generator" content="Cocoa HTML Writer">
                        <meta name="CocoaVersion" content="2575.7">
                            <style type="text/css">
                                :root{
                                    --bg:#0b0f1a; --bg2:#0d1430; --panel:#111827; --panel2:#0f172a; --text:#eaf0ff; --muted:#a7b0c3; --line:rgba(255,255,255,.12);
                                    --accent:#8bb5ff; --accent2:#94f7c3; --warn:#f59e0b; --ok:#22c55e; --danger:#ef4444;
                                }
                                html,body{height:100%}
                                html{-webkit-text-size-adjust:100%;min-height:100%;background:linear-gradient(180deg,var(--bg),var(--bg2));background-attachment:fixed}
                                body{margin:0;background:transparent;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;font-size:clamp(14px,1.8vw,16px)}
                                
                                .wrap{max-width:1100px;margin:24px auto;padding:16px}
                                .section-title{margin:8px 0 6px;font-weight:800;letter-spacing:.2px}
                                
                                .card{background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 12px 30px rgba(0,0,0,.25)}
                                
                                #filters.card{display:flex;flex-direction:column;gap:10px;align-items:flex-start}
                                
                                .label{font-weight:600}
                                .muted{color:var(--muted)}
                                
                                .btn{appearance:none;border:none;background:var(--accent);color:#051127;font-weight:800;padding:10px 14px;border-radius:12px;cursor:pointer;transition:transform .15s ease, box-shadow .2s ease;box-shadow:0 4px 12px rgba(0,0,0,.28)}
                                .btn:hover{transform:translateY(-1px)}
                                .btn:disabled{opacity:.6;cursor:not-allowed;filter:grayscale(.2)}
                                .btn.secondary{background:transparent;color:var(--text);border:1px solid var(--line);box-shadow:0 2px 6px rgba(0,0,0,.18)}
                                .btn, .choice-card{touch-action:manipulation}
                                
                                .controls-row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
                                
                                #match.card{display:grid;grid-template-columns:1fr 80px 1fr;gap:14px;align-items:center;margin-top:14px}
                                .choice-card{appearance:none;-webkit-appearance:none;border:1px solid var(--line);border-radius:12px;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.015));display:flex;flex-direction:column;align-items:center;gap:6px;min-height:170px;cursor:pointer;color:inherit;font:inherit;touch-action:manipulation;width:100%}
                                .choice-card:focus-visible{outline:2px solid var(--accent);outline-offset:2px}
                                .choice-card img{width:128px;height:128px;object-fit:contain;filter:drop-shadow(0 10px 20px rgba(0,0,0,.35))}
                                #championPanel .choice-card {
                                    width:100%;
                                    max-width:320px;
                                    margin:0 auto;
                                }
                                #championPanel {
                                    overflow:hidden;
                                }
                                
                                .vs{display:flex;align-items:center;justify-content:center;color:var(--muted);font-weight:800}
                                .vs::before{content:"VS";display:flex;align-items:center;justify-content:center;width:44px;height:44px;border-radius:999px;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02))}
                                
                                .panel{margin-top:16px}
                                
                                #historyList{border:1px solid var(--line);border-radius:12px;padding:10px;max-height:320px;overflow:auto;background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01))}
                                #historyPanel.card h3,#championPanel.card h3{margin:8px 0 8px}
                                .history-row{display:grid;grid-template-columns:1fr minmax(50px,80px) 1fr auto;gap:12px;align-items:center;padding:8px 0;border-bottom:1px solid var(--line)}
                                .history-row .winner{color:var(--ok);font-weight:800;text-align:right}
                                
                                #pairInfo{margin-left:8px;color:var(--muted)}
                                
                                select, input[type="checkbox"]{accent-color:var(--accent)}
                                select{background:var(--panel2);color:var(--text);border:1px solid var(--line);border-radius:10px;padding:8px 10px}
                                
                                .badge{display:inline-block;font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid var(--line);color:var(--muted)}
                                
                                .kbd-hint{margin:4px 2px 0; font-size:12px}
                                .kbd{display:inline-block; padding:1px 6px; border-radius:6px; background:rgba(255,255,255,.08); border:1px solid var(--line); font-weight:800}
                                
                                @media (max-width:800px){
                                    .wrap{padding:12px}
                                    #match.card{grid-template-columns:1fr 56px 1fr}
                                    .choice-card{min-height:150px}
                                }

                                @media (max-width:700px){
                                  .wrap{padding:10px}
                                  .controls-row{gap:8px}
                                  .btn{padding:12px 16px;font-size:16px}
                                  .choice-card{min-height:160px;padding:14px}
                                  .choice-card img{width:112px;height:112px}
                                  #filters.card{gap:12px}
                                }

                                @media (max-width:560px){
                                  /* Stack the match area vertically */
                                  #match.card{grid-template-columns:1fr;gap:10px}
                                  #leftName{order:1}
                                  .vs{order:2;margin:-2px auto 4px}
                                  #rightName{order:3}
                                  .kbd-hint{font-size:11px}
                                }

                                @media (max-width:420px){
                                  h3.section-title{font-size:16px}
                                  .btn{font-size:15px}
                                  .choice-card img{width:96px;height:96px}
                                  #championPanel .choice-card{max-width:260px}
                                }
                            </style>
                        </head>
    <body>
        <div id="ui" class="wrap">
            <div id="filters" class="card" style="margin-top:10px">
                <h3 class="section-title">Filters</h3>
                <div id="exRow" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
                    <span style="font-weight:600">Exclude:</span>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="exMega" checked> Mega</label>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="exGmax" checked> Gmax</label>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="exCostume" checked> Costumes</label>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="exAltForms" checked> Alt forms</label>
                </div>
                <div id="genRow" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
                    <label for="genSelect" style="font-weight:600">Generation:</label>
                    <select id="genSelect">
                        <option value="">All</option>
                        <option value="generation-i">Gen 1</option>
                        <option value="generation-ii">Gen 2</option>
                        <option value="generation-iii">Gen 3</option>
                        <option value="generation-iv">Gen 4</option>
                        <option value="generation-v">Gen 5</option>
                        <option value="generation-vi">Gen 6</option>
                        <option value="generation-vii">Gen 7</option>
                        <option value="generation-viii">Gen 8</option>
                        <option value="generation-ix">Gen 9</option>
                    </select>
                    <label for="regionSelect" style="font-weight:600">Region:</label>
                    <select id="regionSelect">
                        <option value="">All</option>
                    </select>
                </div>
                <div id="typeRow" style="display:flex;gap:10px;align-items:center;position:relative">
                    <label for="typeDropdownBtn" style="font-weight:600">Types:</label>
                    <button id="typeDropdownBtn" class="btn secondary" type="button" style="padding:6px 10px">Select Types</button>
                    <div id="typeDropdown" style="display:none;position:absolute;top:100%;left:0;margin-top:6px;z-index:20;background:var(--panel2);border:1px solid var(--line);border-radius:10px;padding:10px;box-shadow:0 8px 24px rgba(0,0,0,.35)">
                        <div id="typeBox" style="display:grid;grid-template-columns:repeat(2,minmax(120px,1fr));gap:6px;max-width:320px">
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="normal"> Normal</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="fire"> Fire</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="water"> Water</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="electric"> Electric</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="grass"> Grass</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="ice"> Ice</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="fighting"> Fighting</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="poison"> Poison</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="ground"> Ground</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="flying"> Flying</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="psychic"> Psychic</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="bug"> Bug</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="rock"> Rock</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="ghost"> Ghost</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="dragon"> Dragon</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="dark"> Dark</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="steel"> Steel</label>
                            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" name="typeOpt" value="fairy"> Fairy</label>
                        </div>
                    </div>
                    <div style="margin-top:8px">
                        <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="typesModeAll">Strict Typing</label>
                    </div>
                </div>
                
                <div id="specialRow" style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
                    <span style="font-weight:600">Special:</span>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="onlyLegendary"> Legendary</label>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="onlyMythical"> Mythical</label>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="onlyMega"> Mega</label>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="onlyGmax"> Gmax</label>
                    <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="onlyStarters"> Starters</label>
                    <label id="starterStageWrap" style="display:none;align-items:center;gap:6px">
                        Stage:
                        <select id="starterStage" disabled>
                            <option value="all">All</option>
                            <option value="1">1st</option>
                            <option value="2">2nd</option>
                            <option value="3">3rd</option>
                        </select>
                    </label>
                </div>
                
                <div style="display:flex;flex-direction:column;gap:6px;margin-left:0">
                    <span id="filterCount" style="color:#666"></span>
                </div>
            </div>
            
            <div class="controls-row" style="margin-bottom:6px">
                <button id="startBtn" class="btn">Start Bracket</button>
                <label style="display:flex;align-items:center;gap:6px;margin-left:6px">
                    <input type="checkbox" id="autoShuffleChk">Auto-shuffle each round
                </label>
            </div>
            <div class="controls-row">
                <button id="undoBtn" class="btn secondary" disabled>Undo</button>
                <button id="shuffleBtn" class="btn secondary" disabled>Shuffle Remaining</button>
                <span id="pairInfo" class="muted" aria-live="polite" style="margin-left:auto"></span>
            </div>
            <div class="kbd-hint muted">Shortcuts:
                <span class="kbd">←</span>/<span class="kbd">→</span> to pick,
                <span class="kbd">U</span> to undo,
                <span class="kbd">S</span> to shuffle
            </div>
            
            <div id="match" class="card">
                <button id="leftName"  class="choice-card" type="button"></button>
                <div class="vs"></div>
                <button id="rightName" class="choice-card" type="button"></button>
            </div>
            <div id="championPanel" class="card panel" style="display:none">
                <h3 class="section-title">Champion</h3>
                <div id="championCard" class="choice-card"></div>
            </div>
            <div id="historyPanel" class="card panel">
                <h3 class="section-title">Match History</h3>
                <div id="historyList"></div>
            </div>
        </div>
    </body>
    <script>
        //load JSON
        let pokemonData = []
        let pokedexes = {};
        
        let regionIndex = new Map();
        
        function buildDexIndexes() {
            regionIndex = new Map();
            const values = Object.values(pokedexes || {});
            for (const dex of values) {
                if (!dex || !Array.isArray(dex.entries)) continue;
                const region = (dex.region || '').toLowerCase();
                for (const ent of dex.entries) {
                    const name = (ent.species_name || (Array.isArray(ent) ? ent[2] : '') || '').toLowerCase();
                    if (!name) continue;
                    if (region) {
                        if (!regionIndex.has(region)) regionIndex.set(region, new Set());
                        regionIndex.get(region).add(name);
                    }
                }
            }
        }
        
        async function loadData() {
            const pokeRes = await fetch('pokemon.json');
            let rawPokemon = await pokeRes.json();
            pokemonData = rawPokemon.filter(p => (p.variety_tag || '').toLowerCase() !== 'exclude');
            
            const dexRes = await fetch('pokedexes.json');
            pokedexes = await dexRes.json();
            
            console.log("Loaded", pokemonData.length, "pokemon entries");
            console.log("Available pokedexes:", Object.keys(pokedexes));
            buildDexIndexes();
            populateRegionVersionUI();
            updateFilterCount();
        }
        
        let workingList = [];
        let pairs = [];
        let pairIndex = 0;
        let currentRound = 1;
        let winnersThisRound = [];
        let matchHistory = [];
        let roundPairs = new Map();
        let currentFilters = {
            gen: '',
            types: [],
            typesRequireAll: false,
            excludeMega: true,
            excludeGmax: true,
            excludeCostume: true,
            excludeAltForms: true,
            onlyLegendary: false,
            onlyMythical: false,
            onlyStarters: false,
            starterStage: 'all',
            onlyMega: false,
            onlyGmax: false,
            regions: []
        };
        
        //display logic
        function populateRegionVersionUI() {
            const sel = document.getElementById('regionSelect');
            if (!sel) return;
            sel.innerHTML = '<option value="">All</option>';
            const regions = Array.from(new Set(
                                               Object.values(pokedexes)
                                               .map(d => (d.region || '').toLowerCase())
                                               .filter(Boolean)
                                               )).sort();
                                               for (const r of regions) {
                                                   const label = r.replace(/-/g,' ');
                                                   const nice = label.charAt(0).toUpperCase() + label.slice(1);
                                                   const opt = document.createElement('option');
                                                   opt.value = r;
                                                   opt.textContent = nice;
                                                   sel.appendChild(opt);
                                               }
        }
        
        function labelOf(r) {
            if (!r) return '(unknown)';
            const v = r.variety || '';
            const s = r.species || '';
            const tag = (r.variety_tag || '').toLowerCase();
            if (currentFilters && currentFilters.excludeAltForms && tag === 'form') {
                const base = (s || v || '').replace(/-/g, ' ');
                return base ? base.charAt(0).toUpperCase() + base.slice(1) : '(unknown)';
            }
            if (v && s && v !== s && v.startsWith(s + '-')) {
                const suffix = v.slice(s.length + 1).replace(/-/g, ' ');
                const sp = s.charAt(0).toUpperCase() + s.slice(1);
                const sf = suffix.charAt(0).toUpperCase() + suffix.slice(1);
                return `${sp} (${sf})`;
            }
            const base = (v || s || '').replace(/-/g, ' ');
            return base ? base.charAt(0).toUpperCase() + base.slice(1) : '(unknown)';
        }
        
        function displayName(raw) {
            if (!raw) return '(unknown)';
            const s = String(raw);
            if (/\(.*\)/.test(s)) return s;
            const parts = s.split('-');
            return parts.map((p,i) => i === 0 ? (p.charAt(0).toUpperCase()+p.slice(1)) : p).join('-');
        }
        
        function artworkUrlFor(r) {
            if (!r || !r.variety_id) return null;
            return `./official-artwork/${r.variety_id}.png`;
        }
        
        function cardHTML(r) {
            if (!r) return '';
            const url = artworkUrlFor(r);
            const name = labelOf(r);
            const img = url ? `<img src="${url}" alt="${name}" style="width:128px;height:128px;object-fit:contain;display:block" onerror="this.style.display='none'">` : '';
            return `<div style="display:flex;flex-direction:column;align-items:center;gap:6px">
  ${img}
  <div style="font-weight:700;text-transform:capitalize;text-align:center">${name}</div>
</div>`;
        }
        
        function renderPair() {
            const leftEl = document.getElementById('leftName');
            const rightEl = document.getElementById('rightName');
            const infoEl = document.getElementById('pairInfo');
            const undoBtn = document.getElementById('undoBtn');
            const shuffleBtn = document.getElementById('shuffleBtn');
            undoBtn.disabled = matchHistory.length === 0;
            shuffleBtn.disabled = pairIndex >= pairs.length;
            
            if (pairIndex >= pairs.length) {
                leftEl.innerHTML = '';
                rightEl.innerHTML = '';
                infoEl.textContent = `Done — ${pairs.length} matches`;
                leftEl.disabled = true;
                rightEl.disabled = true;
                leftEl.setAttribute('aria-label', '');
                rightEl.setAttribute('aria-label', '');
                return;
            }
            
            const [a,b] = pairs[pairIndex];
            leftEl.innerHTML = a ? cardHTML(a) : '';
            rightEl.innerHTML = b ? cardHTML(b) : '';
            leftEl.disabled = !a;
            rightEl.disabled = !b;
            leftEl.setAttribute('aria-label', a ? `Choose ${labelOf(a)}` : 'No contestant');
            rightEl.setAttribute('aria-label', b ? `Choose ${labelOf(b)}` : 'No contestant');
            
            infoEl.textContent = `Round ${currentRound} — Match ${pairIndex + 1} of ${pairs.length}`;
        }
        
        function renderHistory() {
            const host = document.getElementById('historyList');
            if (!host) return;
            
            if (!Array.isArray(matchHistory) || matchHistory.length === 0) {
                host.innerHTML = '<div style="color:#777">No matches yet.</div>';
                return;
            }
            
            const byRound = new Map();
            for (const m of matchHistory) {
                if (!byRound.has(m.round)) byRound.set(m.round, []);
                byRound.get(m.round).push(m);
            }
            
            let html = '';
            const rounds = Array.from(byRound.keys()).sort((a,b) => b - a);
            for (const r of rounds) {
                html += `<div style="margin:6px 0 4px;font-weight:700;color:#999">Round ${r}</div>`;
                const rows = byRound.get(r).slice().reverse();
                for (const m of rows) {
                    const a = displayName(m.a);
                    const b = m.b ? displayName(m.b) : '(bye)';
                    const w = displayName(m.winner);
                    html += `<div class="history-row">
            <div style="text-align:right">${a}</div>
            <div class="vs" style="transform:scale(.8)"></div>
            <div style="text-align:left">${b}</div>
            <div class="winner">${w}</div>
         </div>`;
                }
            }
            host.innerHTML = html;
        }
        
        // Champion panel helpers
        function clearChampion() {
            const panel = document.getElementById('championPanel');
            const card  = document.getElementById('championCard');
            if (panel) panel.style.display = 'none';
            if (card) card.innerHTML = '';
        }
        function showChampion(entry) {
            const panel = document.getElementById('championPanel');
            const card  = document.getElementById('championCard');
            if (!panel || !card) return;
            card.innerHTML = cardHTML(entry);
            panel.style.display = '';
            panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        //filter logic
        function asBool(v) {
            return v === true || v === 'TRUE' || v === 'true' || v === 1 || v === '1';
        }
        
        function selectedRegions() {
            const sel = document.getElementById('regionSelect');
            if (!sel) return [];
            const v = sel.value || '';
            return v ? [v.toLowerCase()] : [];
        }
        
        function applyFilters(all, f) {
            let out = all;
            if (f.gen) {
                out = out.filter(p => p.form_intro_gen === f.gen);
            }
            if (Array.isArray(f.types) && f.types.length > 0) {
                if (f.typesRequireAll) {
                    if (f.types.length === 1) {
                        const only = f.types[0];
                        out = out.filter(p => Array.isArray(p.types) && p.types.length === 1 && p.types[0] === only);
                    }
                    else {
                        out = out.filter(p => Array.isArray(p.types) && f.types.every(t => p.types.includes(t)));
                    }
                }
                else {
                    out = out.filter(p => Array.isArray(p.types) && f.types.some(t => p.types.includes(t)));
                }
            }
            if (f.onlyLegendary || f.onlyMythical || f.onlyStarters || f.onlyMega || f.onlyGmax) {
                out = out.filter(p => {
                    const tag = (p.variety_tag || '').toLowerCase();
                    const isMega = (tag === 'mega');
                    const isGmax = (tag === 'gmax');
                    let pass = false;
                    if (f.onlyLegendary && asBool(p.is_legendary)) pass = true;
                    if (f.onlyMythical && asBool(p.is_mythical)) pass = true;
                    if (f.onlyMega && isMega) pass = true;
                    if (f.onlyGmax && isGmax) pass = true;
                    if (f.onlyStarters && asBool(p.is_starter)) {
                        if (f.starterStage === 'all') pass = true;
                        else {
                            const ev = (p.starter_evo != null && p.starter_evo !=='') ? Number(p.starter_evo) : NaN;
                            if (!Number.isNaN(ev) && String(ev) === String(f.starterStage)) pass = true;
                        }
                    }
                    return pass;
                });
            }
            if (Array.isArray(f.regions) && f.regions.length) {
                const allowed = new Set();
                for (const r of f.regions) {
                    const set = regionIndex.get(String(r).toLowerCase());
                    if (set) for (const n of set) allowed.add(n);
                }
                if (allowed.size) {
                    out = out.filter(p => {
                        const key = (p.variety || p.species || '').toLowerCase();
                        return allowed.has(key);
                    });
                }
            }
            out = out.filter(p => {
                const tag = (p.variety_tag || '').toLowerCase();
                if (f.excludeMega && (tag === 'mega' || tag === 'primal')) return false;
                if (f.excludeGmax && tag === 'gmax') return false;
                if (f.excludeCostume && tag === 'costume') return false;
                if (f.excludeAltForms && tag === 'form') return false;
                return true;
            });
            return out;
        }
        
        function updateFilterCount() {
            const el = document.getElementById('filterCount');
            if (!el) return;
            const sample = applyFilters(pokemonData, currentFilters);
            el.textContent = `Matches: ${sample.length} / ${pokemonData.length}`;
        }
        
        //bracket helper functions
        let autoShuffleRounds = false;
        function shuffle(arr) {
            for (let i = arr.length -1; i>0; i--) {
                const j = Math.floor(Math.random() * (i+1));
                [arr[i],arr[j]] = [arr[j],arr[i]];
            }
            return arr;
        }
        
        function buildPairs(list) {
            const out = [];
            for (let i=0; i<list.length; i += 2) {
                const a = list[i];
                const b = list[i + 1] ?? null;
                out.push([a,b]);
            }
            return out;
        }
        
        function recordMatch(round, a, b, winner) {
            matchHistory.push({
                round,
                a: (typeof a === 'object' ? (a.variety || a.species || String(a)) : String(a)),
                b: (b ? (typeof b === 'object' ? (b.variety || b.species || String(b)) : String(b)) : null),
                winner: (typeof winner === 'object' ? (winner.variety || winner.species || String(winner)) : String(winner)), winner_obj: winner
            });
            renderHistory();
        }
        
        //bracket core logic
        function pickWinner(side) {
            if (pairIndex >= pairs.length) return;
            
            const [a,b] = pairs[pairIndex];
            let winner = a;
            
            if (b && side === 'right') {
                winner = b;
            }
            
            winnersThisRound.push(winner);
            recordMatch(currentRound, a, b, winner);
            pairIndex++;
            
            if (pairIndex >= pairs.length) {
                if (winnersThisRound.length === 1) {
                    const champ = winnersThisRound[0];
                    const infoEl = document.getElementById('pairInfo');
                    const champName = labelOf(champ);
                    infoEl.textContent = `Tournament complete — ${champName} wins!`;
                    document.getElementById('leftName').textContent = '';
                    document.getElementById('rightName').textContent = '';
                    showChampion(champ);
                    return;
                }
                
                const finishedRound = currentRound;
                const nextEntrants = winnersThisRound.slice();
                currentRound = finishedRound+1;
                workingList = nextEntrants;
                if (autoShuffleRounds) shuffle(workingList);
                winnersThisRound = [];
                pairs = buildPairs(workingList);
                roundPairs.set(currentRound, pairs.slice());
                pairIndex = 0;
            }
            renderPair();
        }
        
        function undoLast() {
            if (pairIndex > 0) {
                pairIndex--;
                matchHistory.pop();
                if (winnersThisRound.length > 0) winnersThisRound.pop();
                renderPair();
                renderHistory();
                return
            }
            
            if (currentRound > 1) {
                const prevRound = currentRound-1;
                const prevPairs = roundPairs.get(prevRound) || [];
                pairs = prevPairs.slice();
                currentRound = prevRound;
                
                let lastIdx = -1;
                for(let i = matchHistory.length-1;i>=0;i--) {
                    if (matchHistory[i].round === prevRound) {lastIdx = i; break;}
                }
                if (lastIdx !== -1) {
                    matchHistory.splice(lastIdx,1);
                }
                
                winnersThisRound = matchHistory.filter(m => m.round === prevRound).map(m => m.winner_obj).filter(Boolean);
                pairIndex = winnersThisRound.length;
                renderPair();
                renderHistory();
                return;
            }
        }
        
        function shuffleRemaining() {
            if (!Array.isArray(pairs) || pairs.length === 0) return;
            if (pairIndex >= pairs.length) return;
            
            const remaining = [];
            for (let i = pairIndex;i<pairs.length;i++) {
                const [a,b] = pairs[i];
                if (a) remaining.push(a);
                if (b) remaining.push(b)
            }
            if (remaining.length <= 1) return;
            shuffle(remaining);
            const newRemainingPairs = buildPairs(remaining);
            const kept = pairs.slice(0,pairIndex);
            pairs = kept.concat(newRemainingPairs);
            roundPairs.set(currentRound, pairs.slice());
            renderPair();
        }
        
        async function startBracket() {
            currentRound = 1;
            winnersThisRound = [];
            matchHistory = [];
            roundPairs = new Map();
            clearChampion();
            
            const historyHost = document.getElementById('historyList');
            
            workingList = applyFilters(pokemonData, currentFilters);
            
            if (!workingList.length) {
                document.getElementById('filterCount').textContent = "No Pokemon match the current filters.";
                return;
            }
            shuffle(workingList);
            const infoEl = document.getElementById('pairInfo');
            if (infoEl) infoEl.textContent = '';
            
            pairs = buildPairs(workingList);
            roundPairs.set(currentRound, pairs.slice());
            pairIndex = 0;
            renderPair();
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const $ = (id) => document.getElementById(id);
            
            // Cache controls
            const filtersHost   = $('filters');
            const genSelect     = $('genSelect');
            const typeBox       = $('typeBox');
            const typesModeAll  = $('typesModeAll');
            
            const exMega        = $('exMega');
            const exGmax        = $('exGmax');
            const exCostume     = $('exCostume');
            const exAltForms    = $('exAltForms');
            
            const onlyMega      = $('onlyMega');
            const onlyGmax      = $('onlyGmax');
            const onlyLegendary = $('onlyLegendary');
            const onlyMythical  = $('onlyMythical');
            const onlyStarters  = $('onlyStarters');
            const starterStage  = $('starterStage');
            
            // Helper to read selected types
            const getSelectedTypes = () => Array.from(document.querySelectorAll('input[name="typeOpt"]:checked')).map(el => el.value);
            
            function syncOnlyExclude() {
                if (onlyMega && onlyMega.checked) { currentFilters.excludeMega = false; if (exMega) exMega.checked = false; }
                if (onlyGmax && onlyGmax.checked) { currentFilters.excludeGmax = false; if (exGmax) exGmax.checked = false; }
            }
            
            function readFiltersFromUI() {
                currentFilters.gen              = genSelect ? (genSelect.value || '') : '';
                currentFilters.types            = getSelectedTypes();
                currentFilters.typesRequireAll  = !!(typesModeAll && typesModeAll.checked);
                
                currentFilters.excludeMega      = !!(exMega && exMega.checked);
                currentFilters.excludeGmax      = !!(exGmax && exGmax.checked);
                currentFilters.excludeCostume   = !!(exCostume && exCostume.checked);
                currentFilters.excludeAltForms  = !!(exAltForms && exAltForms.checked);
                
                currentFilters.onlyMega         = !!(onlyMega && onlyMega.checked);
                currentFilters.onlyGmax         = !!(onlyGmax && onlyGmax.checked);
                currentFilters.onlyLegendary    = !!(onlyLegendary && onlyLegendary.checked);
                currentFilters.onlyMythical     = !!(onlyMythical && onlyMythical.checked);
                currentFilters.onlyStarters     = !!(onlyStarters && onlyStarters.checked);
                currentFilters.starterStage     = starterStage ? (starterStage.value || 'all') : 'all';
                
                currentFilters.regions       = selectedRegions();
                
                const stageWrap = document.getElementById('starterStageWrap');
                if (stageWrap) stageWrap.style.display = currentFilters.onlyStarters ? 'flex' : 'none';
                if (starterStage) starterStage.disabled = !currentFilters.onlyStarters;
                
                syncOnlyExclude();
                
                updateFilterCount();
            }
            
            if (filtersHost) {
                filtersHost.addEventListener('change', (e) => {
                    readFiltersFromUI();
                });
            }
            
            readFiltersFromUI();
            
            // Types dropdown toggle logic
            const typeDropdownBtn = $('typeDropdownBtn');
            const typeDropdown    = $('typeDropdown');
            if (typeDropdownBtn && typeDropdown) {
                typeDropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const open = typeDropdown.style.display === 'block';
                    typeDropdown.style.display = open ? 'none' : 'block';
                });
                document.addEventListener('click', (e) => {
                    if (!typeDropdown.contains(e.target) && e.target !== typeDropdownBtn) {
                        typeDropdown.style.display = 'none';
                    }
                });
            }
            
            const autoShuffleChk = document.getElementById('autoShuffleChk');
            if (autoShuffleChk) {
                autoShuffleChk.addEventListener('change', () => {
                    autoShuffleRounds = !!autoShuffleChk.checked;
                });
            }
        });
        
        document.getElementById('startBtn').addEventListener('click', startBracket);
        document.getElementById('undoBtn').addEventListener('click', undoLast);
        document.getElementById('shuffleBtn').addEventListener('click', shuffleRemaining);
        document.getElementById('leftName').addEventListener('click', () => pickWinner('left'));
        document.getElementById('rightName').addEventListener('click', () => pickWinner('right'));
        window.addEventListener('DOMContentLoaded', loadData);
        
        //keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : '';
            if (tag === 'input' || tag === 'select' || tag === 'textarea' || (document.activeElement && document.activeElement.isContentEditable)) {
                return;
            }
            
            switch (e.key) {
                case 'ArrowLeft':
                e.preventDefault();
                if (Array.isArray(pairs) && pairIndex < pairs.length) pickWinner('left');
                break;
                case 'ArrowRight':
                e.preventDefault();
                if (Array.isArray(pairs) && pairIndex < pairs.length) pickWinner('right');
                break;
                case 'u':
                case 'U':
                e.preventDefault();
                undoLast();
                break;
                case 's':
                case 'S':
                e.preventDefault();
                shuffleRemaining();
                break;
                default:
                break;
            }
        });
    </script>
</html>
